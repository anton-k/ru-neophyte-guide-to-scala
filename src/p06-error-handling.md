Глава 6: Обработка исключений с помощью Try
===========================================

При знакомстве с новым языком мы можем писать простые программы, забывая о возможности
появления исключительных ситуаций. Но мы не можем игнорировать их, если собираемся
писать что-либо серьёзное. Часто по той или иной причине возможности языка, 
связанные с обработкой исключений, недооцениваются.

Как оказывается, в Scala предусмотрены весьма элегантные средства для работы с ошибками.
В этой статье мы познакомимся с типом `Try`, основой для обработки исключений в Scala.
Эти возможности стали доступны начиная с версии 2.10, они также портированы в 2.9.3.
Так что убедитесь в том, что вы пользуетесь компилятором Scala версии не ниже чем 2.9.3.

Создание и обработка исключений
--------------------------------------------------

Перед тем как перейти к идиоматичному способу обработки исключений, давайте посмотрим
на способ, знакомый нам по другим языкам, таким как Java или Ruby. В Scala мы можем создавать
исключения точно так же:

~~~scala
case class Customer(age: Int)

class Cigarettes

case class UnderAgeException(message: String) extends Exception(message)

def buyCigarettes(customer: Customer): Cigarettes =
  if (customer.age < 16)
    throw UnderAgeException(s"Customer must be older than 16 but was ${customer.age}")
  else new Cigarettes
~~~

Созданные исключения могут быть обработаны так же, как и в Java, только в Scala
мы воспользуемся сопоставлением с образцом, для того чтобы определить, какие исключения
мы хотим обработать:

~~~scala
val youngCustomer = Customer(15)
try {
  buyCigarettes(youngCustomer)
  "Yo, here are your cancer sticks! Happy smokin'!"
} catch {
    case UnderAgeException(msg) => msg
}
~~~

Обработка исключений в функциональном стиле
--------------------------------------------------

Мы можем очень быстро засорить наше приложение таким способом обработки исключений. Но он совсем не
вяжется с функциональным программированием. Также это решение плохо подходит для параллельных приложений.
Например, если исключение случится в акторе, который выполняется в другом потоке, мы не сможем обработать
это исключение; вместо этого нам бы хотелось получить сообщение, обозначающее исключительную ситуацию.

Поэтому в Scala предпочтительным способом обозначения исключений является возвращение специального
значения из функции. 

Но не волнуйтесь, мы вовсе не собираемся возвращаться к кодам ошибок, принятым в C, проверка которых 
обусловлена лишь соглашениями. В Scala мы воспользуемся специальным типом, который говорит о том, что 
вычисление может привести к ошибке.

В этой главе мы ограничимся рассмотрением типа `Try`, который был включён в Scala с версии 2.10 и
позднее портирован в 2.9.3. Также есть очень похожий тип `Either`: на практике возникают ситуации, когда
нам нужен именно этот тип, но он более общий.

### Семантика Try

Смысл типа `Try` лучше всего объяснить, сравнив его с типом `Option`, о котором шла речь в предыдущей статье.

В то время как `Option[A]` представляет собой контейнер, который может содержать одно значение типа `A`
или быть пустым, тип `Try[A]` описывает вычисление, которое может вернуть значение типа `A`, если оно завершится
успешно или некоторый объект из класса `Throwable`, если что-то пойдёт не так. Значения типа `Try[A]` могут
быть легко переданы между разными одновременно выполняющимися частями приложения. 

Существует два варианта для типа `Try`. Если вычисление окончилось успешно, `Try[A]` содержит 
объект типа `Success[A]` - это просто значение типа `A`, обёрнутое в конструктор `Success`. 
Если вычисление завершилось с ошибкой, значение содержит объект из класса `Failure[A]`
с исключением типа `Throwable`.  

Если нам известно, что вычисление может закончиться с ошибкой, то мы можем просто
использовать `Try[A]` в качестве типа возвращаемого значения. Благодаря этому пользователь
нашей функции по сигнатуре типа будет знать о том, что что-то может пойти не так. 

Предположим, что нам нужно написать простой загрузчик веб-страниц. Пользователь 
может набрать URL страницы, которую он хочет просмотреть. Где-то в приложении нам
нужно разобрать URL из строки и преобразовать его в `java.net.URL`:

~~~scala
import scala.util.Try
import java.net.URL
def parseURL(url: String): Try[URL] = Try(new URL(url))
~~~

Как видно из определения, мы возвращаем результат типа `Try[URL]`. Если URL построен правильно, мы вернём 
`Success[URL]`. Если конструктор URL выбросит исключение `MalformedURLException`, оно будет
обёрнуто в `Failure[A]`. 

Для этого мы воспользовались методом `apply` из объекта-компаньона для `Try`. Этот метод
принимает значение типа `A` по имени (в данном случае URL). Для нашего примера это означает,
что `new URL(url)` будет выполнено внутри метода `apply` из объекта  `Try`. В этом методе
происходит обработка не фатальных (non-fatal) исключений; если случится исключение, то
метод вернёт `Failure`. 

Так `parseURL("http://danielwestheide.com")` вернёт `Success[URL]`, в то время как 
`parseURL("garbage")` вернёт `Failure[URL]` с исключением `MalformedURLException` внутри. 

### Использование значений типа `Try`

Тип `Try` очень похож на тип `Option`, поэтому нас ждёт мало неожиданностей.

Мы можем узнать, завершилось ли вычисление успешно, вызовом метода `isSuccess` 
для значения типа `Try` и затем извлечь значение с помощью `get`. Но, поверьте
мне на слово, мы будем пользоваться этими методами не так часто.

Также для `Try` определён метод `getOrElse`, который возвращает значение по умолчанию
в случае возникновения исключения.

~~~scala
val url = parseURL(Console.readLine("URL: ")) getOrElse new URL("http://duckduckgo.com")
~~~

Если пользователь набрал неверный URL, мы перейдём по адресу поисковика DuckDuckGo.

#### Цепочки операций

Важной особенностью типа `Try` является то, что он, также как и `option`, поддерживает все методы для коллекций.
Совсем скоро мы рассмотрим несколько примеров и вы убедитесь в наглядности обработки исключений в типе `Try`.  

#### Методы map и flatMap

Метод `map` отображает `Try[A]` из `Success[A]` в `Success[B]`. Если значение содержит `Failure[A]`, то результат `Try[B]` 
также  будет содержать `Failure[B]` вместе с тем же исключением, что и в `Failure[A]`.

~~~scala
parseURL("http://danielwestheide.com").map(_.getProtocol)
// results in Success("http")
parseURL("garbage").map(_.getProtocol)
// results in Failure(java.net.MalformedURLException: no protocol: garbage)
~~~

Если мы проводим несколько вызовов `map` на функциях с исключениями, то мы 
получим вложенные значения типа `Try`, чего хотелось бы избежать. Например, посмотрим на метод,
который возвращает данные для данного URL:

~~~scala
import java.io.InputStream
def inputStreamForURL(url: String): Try[Try[Try[InputStream]]] = parseURL(url).map { u =>
  Try(u.openConnection()).map(conn => Try(conn.getInputStream))
}
~~~

Поскольку каждая из функций, что переданы в `map`, возвращает `Try`, мы получили на выходе
тип `Try[Try[Try[InputStream]]]`.

Самое время воспользоваться методом `flatMap`. Метод `flatMap` на значении `Try[A]` принимает функцию,
которая переводит `A` в `Try[B]`. Если наше значение уже содержит исключение, оно перейдёт в результат
типа `Failure[B]`, мы пропустим вызов функции. Если же `Try[A]` содержит `Success[A]` метод `flatMap`
извлечёт значение типа `A`, применит к нему функцию и вернёт значение типа `Try[B]`.

Так мы можем строить цепочки вызовов функций, которые могут завершиться исключениями. 
Если где-то среди вызовов случится  исключение, оно будет обвёрнуто в `Failure` и именно
оно и будет возвращено в качестве результата.  

Давайте перепишем предыдущий пример через `flatMap`:

~~~scala
def inputStreamForURL(url: String): Try[InputStream] = parseURL(url).flatMap { u =>
  Try(u.openConnection()).flatMap(conn => Try(conn.getInputStream))
}
~~~

#### Filter и foreach

Также мы можем проводить фильтрацию для `Try` или вызывать метод `foreach`. 
Эти методы работают точно так же, как и в случае `Option`.

Метод `filter` вернёт `Failure`, если значение уже содержит `Failure` или
если предикат вернёт ложь (тогда на выходе мы получим исключение `NoSuchElementException`). 
Если значение `Try`, содержит `Success[A]` и предикат вернёт истину, тогда на выходе
будет то же самое значение:

~~~scala
def parseHttpURL(url: String) = parseURL(url).filter(_.getProtocol == "http")
parseHttpURL("http://apache.openmirror.de") // results in a Success[URL]
parseHttpURL("ftp://mirror.netcologne.de/apache.org") // results in a Failure[URL]
~~~

Функция, переданная в `foreach`, выполняется только в том случае, если `Try` 
содержит `Success[A]`. Метод `foreach` извлечёт значение и выполнит все побочные эффекты
из переданной процедуры. Функция будет вызвана только один раз. 

~~~scala
parseHttpURL("http://danielwestheide.com").foreach(println)
~~~

#### For-генераторы

Так как для `Try` определены методы `map`, `filter` и `flatMap`, мы можем воспользоваться 
`for`-генераторами. В большинстве случаев `for`-генераторы делают код гораздо более наглядным.
Например, реализуем метод, возвращающий содержание страницы по данному адресу:

~~~scala
import scala.io.Source
def getURLContent(url: String): Try[Iterator[String]] =
  for {
    url <- parseURL(url)
    connection <- Try(url.openConnection())
    is <- Try(connection.getInputStream)
    source = Source.fromInputStream(is)
  } yield source.getLines()
~~~

Ошибки могут случиться, по крайней мере, в трёх местах. Тип `Try` используется в каждом из них. 
Во первых, метод `parseURL` возвращает `Try[URL]`. Мы продолжим вычисления только в случае
успешного завершения этого метода (`Success[URL]`). Тогда мы попытаемся установить соединение 
и создать поток данных. Если эти операции завершатся успешно, мы продолжим и наконец вернём
содержание веб-страницы. Поскольку в этом выражении мы комбинируем несколько вызовов `flatMap`, 
тип итогового значения будет просто `Try[Iterator[String]]`.

Обратите внимание на то, что на практике мы могли бы воспользоваться функцией `Source.fromUrl`, 
также мы забыли закрыть соединение. Я специально опустил эти детали, для того чтобы сосредоточиться
на особенностях использования `Try`.

Сопоставление с образцом
-------------------------------------------

Довольно часто на практике встречаются ситуации, в которых нам явно хочется проверить,
что же произошло с вычислением. Закончилось ли оно успешно или произошла ошибка.
Мы можем сделать это с помощью сопоставления с образцом, поскольку и `Success`, 
и `Failure` являются `case`-классами.

Предположим, что мы хотим показать пользователю веб-страницу или сообщение об ошибке,
если загрузить страницу не удалось:

~~~scala
import scala.util.Success
import scala.util.Failure
getURLContent("http://danielwestheide.com/foobar") match {
  case Success(lines) => lines.foreach(println)
  case Failure(ex) => println(s"Problem rendering URL content: ${ex.getMessage}")
}
~~~

Восстановление после ошибки
-----------------------------------------------

Для продолжения вычислений после ошибки мы можем воспользоваться не только методом `getOrElse`. 
Метод `recover` принимает частично определённую функцию и возвращает `Try`. 
Если значение, на котором был вызван метод `recover`, завершится успешно, будет возвращён результат
`Success[A]`, в случае исключения будет вызвана частично определённая функция. Если она определена
для исключения, которое произошло, будет вызвана функция и результат будет обвёрнут в `Success`.

Давайте с помощью метода `recover` вернём различные сообщения об ошибках в зависимости от типа исключения: 

~~~scala
import java.net.MalformedURLException
import java.io.FileNotFoundException
val content = getURLContent("garbage") recover {
  case e: FileNotFoundException => Iterator("Requested page does not exist")
  case e: MalformedURLException => Iterator("Please make sure to enter a valid URL")
  case _ => Iterator("An unexpected error has occurred. We are so sorry!")
}
~~~

Теперь мы можем спокойно извлечь значение из `Try[Iterator[String]]`. Нам известно,
что оно определено. Вызов `content.get.foreach(println)` приведёт к печати сообщения
`Please make sure to enter a valid URL` being printed to the console.

Заключение
---------------------------------------------

Идиоматичная обработка исключений происходит в Scala совсем не так как в Java или Ruby. 
Тип `Try` позволяет элегантно комбинировать вычисления, которые могут завершиться с ошибкой.
И всё это работает точно так же, как и в коллекциях!

Мы не успели рассмотреть все методы для `Try`. Так же как и в `Option`, в `Try` есть метод `orElse`.
Стоит присмотреться к методам `transform` и `recoverWith`.

В следующей статье речь пойдёт о типе `Either`, другом способе представления вычислений,
которые могут завершиться с ошибкой. Тип `Either` &mdash; гораздо более общий, сфера его применения
 не ограничивается обработкой исключений.


----------------------------------------------------

* <= [Глава 5: Тип Option](https://github.com/anton-k/ru-neophyte-guide-to-scala/blob/master/src/p05-option.md)

* => [Глава 7: Тип Either](https://github.com/anton-k/ru-neophyte-guide-to-scala/blob/master/src/p07-either.md)

* [Содержание](https://github.com/anton-k/ru-neophyte-guide-to-scala#%D0%9F%D1%83%D1%82%D0%B5%D0%B2%D0%BE%D0%B4%D0%B8%D1%82%D0%B5%D0%BB%D1%8C-%D0%BD%D0%B5%D0%BE%D1%84%D0%B8%D1%82%D0%B0-%D0%BF%D0%BE-scala)
